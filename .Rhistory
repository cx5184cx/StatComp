devtools::document()
devtools::build_vignettes()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::check()
devtools::document()
devtools::build()
devtools::check()
devtools::document()
devtools::build_vignettes()
devtools::document()
devtools::check()
devtools::document()
rm(list=ls())
devtools::document()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
rm(list=ls())
devtools::document()
devtools::build()
devtools::build()
devtools::build()
devtools::check()
Sys.which(Sys.getenv("R_QPDF","qpdf"))
rm(list=ls())
devtools::document()
rm(list=ls())
devtools::document()
devtools::check()
path<-"C:/Users/user/Desktop/毕业设计/S&P500股价"
fileNames <- dir(path)  ##??ȡ??·???µ??ļ???
filePath <- sapply(fileNames, function(x){
paste(path,x,sep='/')})   ##???ɶ?ȡ?ļ?·??
T <- lapply(filePath, function(x){
read.csv(x, header=TRUE)})
d=NULL
for(i in 1:length(T)){
d[i]=length(T[[i]][,3])
}
T=T[d>=max(d)]    #??ȡ??ʮ?????ݵ?
n=length(T)
#ȡ???????ݼ?????
data=list()
for(i in 1:n){
data=c(data,list(log(T[[i]][,5])))
}
names(data)=names(T)
data
Z=read.csv("C:/Users/user/Desktop/毕业设计/Z.csv",header=F)
Z
get_data=function(data,A){
i=1
while(i<=length(data)){
name=sub('\\.csv','',names(data[i]))
if(!name%in%names(A[,1])){
data=data[-i]
}
if(name%in%names(A[,1]))i=i+1
}
return(data)
}
get_A=function(data,A){
i=1
while(i<=length(A[,1])){
name=paste(names(A[,1])[i],".csv",sep="")
if(!name%in%names(data)){
A=A[-i,]
A=A[,-i]
}
if(name%in%names(data)) i=i+1
}
return(A)
}
generate1=function(Z){
A=read.csv("C:/Users/user/Desktop/毕业设计/A.csv",header=F)
A=as.matrix(A)
for(i in 1:390)
for(j in (i+1):391)
A[i,j]=A[j,i]
for(i in 1:391)
for(j in 1:391)
if(A[i,j]>5) A[i,j]=1 else A[i,j]=0
colnames(A)=Z[-1,1]
rownames(A)=Z[-1,1]
#ȥ??ȫΪ0???У???
i=1
while(i<=nrow(A)){
q=0
for(j in 1:ncol(A))
if(A[i,j]==0)q=q+1
if(q==nrow(A)){
A=A[-i,]
A=A[,-i]
}
else i=i+1
}
return(A)
}
#ѡ????Ҫ??Z
get_Z=function(Z,A){
i=1
while(i<=length(Z[,1])){
if(!Z[i,1]%in%names(A[,1])){
Z=Z[-i,]
}
if(Z[i,1]%in%names(A[,1]))i=i+1
}
z=Z[,1]
Z=Z[,-1]
Z=as.matrix(Z)
for(j in 1:ncol(Z))
for(k in 1:nrow(Z))
if(is.na(Z[k,j])) Z[k,j] <- mean(as.numeric(Z[,j]),na.rm = TRUE)
Z=as.numeric(Z)
Z=matrix(Z,ncol=5)
z=as.vector(z)
rownames(Z)=z
return(Z)
}
Zi=function(name,Z){
i=Z[names(Z)==name]
return(i)
}
A=generate1(Z)                     ###??ͬ?ɶ?
data=get_data(data,A)
A=get_A(data,A)
Z=get_Z(Z,A)
A
Z
data
dim(data)
nrow(data)
data
summary(data)
dim(data)
Z=as.matrix(Z)
length(data)
getwd()
save(A, file = "A.rda")
save(Z, file = "Z.rda")
save(data, file = "data.rda")
rm(list=ls())
devtools::document()
rm(list=ls())
devtools::document()
devtools::build()
devtools::check()
devtools::check()
devtools::check()
rm(list=ls())
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
path<-"C:/Users/user/Desktop/毕业设计/S&P500股价"
fileNames <- dir(path)  ##??ȡ??·???µ??ļ???
filePath <- sapply(fileNames, function(x){
paste(path,x,sep='/')})   ##???ɶ?ȡ?ļ?·??
T <- lapply(filePath, function(x){
read.csv(x, header=TRUE)})
d=NULL
for(i in 1:length(T)){
d[i]=length(T[[i]][,3])
}
T=T[d>=max(d)]    #??ȡ??ʮ?????ݵ?
n=length(T)
#ȡ???????ݼ?????
data=list()
for(i in 1:n){
data=c(data,list(log(T[[i]][,5])))
}
names(data)=names(T)
path<-"C:/Users/user/Desktop/毕业设计/S&P500股价"
fileNames <- dir(path)  ##??ȡ??·???µ??ļ???
filePath <- sapply(fileNames, function(x){
paste(path,x,sep='/')})   ##???ɶ?ȡ?ļ?·??
T <- lapply(filePath, function(x){
read.csv(x, header=TRUE)})
d=NULL
for(i in 1:length(T)){
d[i]=length(T[[i]][,3])
}
T=T[d>=max(d)]    #??ȡ??ʮ?????ݵ?
n=length(T)
#ȡ???????ݼ?????
data=list()
for(i in 1:n){
data=c(data,list(log(T[[i]][,5])))
}
names(data)=names(T)
Z=read.csv("C:/Users/user/Desktop/毕业设计/Z.csv",毕业设计)
A=generate1(Z)                     ###??ͬ?ɶ?
data=get_data(data,A)
A=get_A(data,A)
data
get_data=function(data,A){
i=1
while(i<=length(data)){
name=sub('\\.csv','',names(data[i]))
if(!name%in%names(A[,1])){
data=data[-i]
}
if(name%in%names(A[,1]))i=i+1
}
return(data)
}
get_A=function(data,A){
i=1
while(i<=length(A[,1])){
name=paste(names(A[,1])[i],".csv",sep="")
if(!name%in%names(data)){
A=A[-i,]
A=A[,-i]
}
if(name%in%names(data)) i=i+1
}
return(A)
}
generate1=function(Z){
A=read.csv("C:/Users/user/Desktop/毕业设计/A.csv",header=F)
A=as.matrix(A)
for(i in 1:390)
for(j in (i+1):391)
A[i,j]=A[j,i]
for(i in 1:391)
for(j in 1:391)
if(A[i,j]>5) A[i,j]=1 else A[i,j]=0
colnames(A)=Z[-1,1]
rownames(A)=Z[-1,1]
#ȥ??ȫΪ0???У???
i=1
while(i<=nrow(A)){
q=0
for(j in 1:ncol(A))
if(A[i,j]==0)q=q+1
if(q==nrow(A)){
A=A[-i,]
A=A[,-i]
}
else i=i+1
}
return(A)
}
#ѡ????Ҫ??Z
get_Z=function(Z,A){
i=1
while(i<=length(Z[,1])){
if(!Z[i,1]%in%names(A[,1])){
Z=Z[-i,]
}
if(Z[i,1]%in%names(A[,1]))i=i+1
}
z=Z[,1]
Z=Z[,-1]
Z=as.matrix(Z)
for(j in 1:ncol(Z))
for(k in 1:nrow(Z))
if(is.na(Z[k,j])) Z[k,j] <- mean(as.numeric(Z[,j]),na.rm = TRUE)
Z=as.numeric(Z)
Z=matrix(Z,ncol=5)
z=as.vector(z)
rownames(Z)=z
return(Z)
}
Zi=function(name,Z){
i=Z[names(Z)==name]
return(i)
}
Z=read.csv("C:/Users/user/Desktop/毕业设计/Z.csv",header=F)
Z
A=generate1(Z)                     ###??ͬ?ɶ?
data=get_data(data,A)
A=get_A(data,A)
Z=get_Z(Z,A)
Z=as.matrix(Z)
Z
dim(Z)
length(data)
save(A, file='A.rda', compress='xz')
save(Z, file='Z.rda', compress='xz')
save(data, file='data.rda', compress='xz')
rm(list=ls())
devtools::document()
rm(list=ls())
devtools::document()
devtools::check()
rm(list=ls())
devtools::document()
devtools::build_vignettes()
GNAR<-function(A,Z,data,begin,end,K,t)
{
### Two step estimation
Cluster.NAR<-function(Ymat, W,  Z, K, method = "complete",  group = NULL)
{
N = nrow(Ymat)
Time = ncol(Ymat)
Ymat1 = W%*%Ymat
### 求得回顾数据集
if (is.null(Z))
yy_dat = data.frame(id = rep(1:N, each = Time - 1),
inter = 1,
net = as.vector(t(Ymat1[,-ncol(Ymat)])),
lagY = as.vector(t(Ymat[,-ncol(Ymat)])),
Y = as.vector(t(Ymat[,-1])))
else
yy_dat = data.frame(id = rep(1:N, each = Time - 1),
inter = 1,
net = as.vector(t(Ymat1[,-ncol(Ymat)])),
lagY = as.vector(t(Ymat[,-ncol(Ymat)])),
Z[rep(1:N, each = Time-1),],
Y = as.vector(t(Ymat[,-1])))
### 对每个节点求b_i估计值
paras = ddply(yy_dat, .(id), function(x){
X = as.matrix(x[,2:4])
invXX = ginv(crossprod(X))                                                                                   ### the response vector
thetaEst = invXX%*%colSums(X*x$Y)
df = data.frame(matrix(c(thetaEst), nrow = 1))
})
colnames(paras)[-1] = c("intercept", "network", "momentum")
### 规范化网络和动量参数并计算节点的距离
para_scale = apply(paras[,3:4], 2, function(x) x/max(abs(x)))#scale(paras[,3:4])
para_dist = dist(as.matrix(para_scale))
### 实施聚类算法
if (method=="kmeans")
{
#nar_para = betaOLS(Ymat, W, Z)
#ini_theta = (sapply(nar_para$theta[2:3], function(x) runif(K, min = x-0.05, max = x+0.05)))
k_res = kmeans(para_scale, K)
memb = k_res$cluster
}
else
{
hcl = hclust(para_dist, method = method)
memb = cutree(hcl, k = K)
}
alpha = table(memb)/length(memb)
yy_dat$group = rep(memb, each = Time - 1) # 求得不同节点的组
### 对每个组重新进行估计
theta_est = ddply(yy_dat, .(group), function(x){
X = as.matrix(x[,2:(ncol(x)-2)])
invXX = ginv(crossprod(X))                                                                                   ### the response vector
thetaEst = invXX%*%colSums(X*x$Y)
df = data.frame(matrix(c(thetaEst), nrow = 1))
})
return(list(theta = t(theta_est)[-1,], alpha = alpha, group = memb))
}
N=length(data)
L=end-begin+1
data1=matrix(0,nrow=N,ncol=L)
for(i in 1:N) data1[i,]=data[[i]][begin:end]
for(j in 1:t) data1=cbind(data1,0)
W=A/rowSums(A)
W[is.na(W)]=0
Z=as.matrix(Z)
cl_res = Cluster.NAR(data1, W, Z, K, method = "complete") # two-step estimation
theta=cl_res$theta
group=cl_res$group
D=NULL
before=NULL  #最后一个数据的值
prob=NULL
forecast=matrix(0,nrow=N,ncol=t)  #预测值
real=matrix(0,nrow=N,ncol=t)  #真实值
D=matrix(0,nrow=N,ncol=t)     #是否正确
for(i in 1:N)before[i]=exp(data[[i]][end])
for(j in 1:t){
Ymat=data1[,1:(L+j-1)]
WYmat = W%*%Ymat
N = nrow(Ymat)
Time = ncol(Ymat)
if (is.null(Z))
X = cbind(1, lagWY = as.vector(WYmat), lagY = as.vector(Ymat))
else
X = cbind(1, lagWY = as.vector(WYmat), lagY = as.vector(Ymat),
do.call(rbind, rep(list(Z), Time)))
Yhat = matrix((X%*%theta)[cbind(1:nrow(X), rep(group, Time))], nrow = N)
data1[,L+j]=Yhat[,L+j-1]
}
for(j in 1:t)  forecast[,j]=data1[,L+j]
for(j in 1:t){
for(i in 1:N){
real[i,j]=exp(data[[i]][end+j])
if((real[i,j]-before[i])*(forecast[i,j]-before[i])>0)
D[i,j]=1
if((real[i,j]-before[i])*(forecast[i,j]-before[i])<=0)
D[i,j]=0
}
prob[j]=sum(D[,j])/length(D[,j])
}
M=cbind(before,real,forecast,D)
colnames(M)=c("before",rep("real",t),rep("forecast",t),rep("D",t))
rownames(M)=names(A[,1])
return(list(M,prob))
}
Z
data
Z=data(Z)
Z
load("C:/Users/user/Desktop/StatComp-20099/data/A.rda")
A
load("C:/Users/user/Desktop/StatComp-20099/data/Z.rda")
Z
load("C:/Users/user/Desktop/StatComp-20099/data/data.rda")
M = GNAR(A,Z,data,1,503,2,10)
M
rm(list=ls())
devtools::document()
devtools::build_vignettes()
rm(list=ls())
devtools::document()
devtools::build_vignettes()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
install.packages('../StatComp_1.0.tar.gz',repo=NULL)
install.packages('C:/Users/user/Desktop/StatComp20099_1.0.tar.gz',repo=NULL)
